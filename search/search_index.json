{"config":{"lang":["en"],"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Chenghao 's Project Site \u00b6 Research Studies \u00b6 Fast Food Study Egg Study Ghana Study Alzheimer Study Github Projects \u00b6 Metabase R package for storing, handling, anlyzing, and visualizing high though-put experiment data, such as metabolomics and proteomics. ShinyMetabase A shiny app wrapped in an R package for metabolomics data analysis, including data normalization, linear model, multivariable analysis and network analysis. phylox R package for storing, handling, analyzing and visualizing phylogenic sequencing data in different phylogenic levels. zheatmap R package for generating clustered and annotated heatmaps using ggplot2 package. ggmetaplots R package with encapsulated functions to generate different plots that is frequently used, such as boxplot and scatterplot. Softwares/Apps \u00b6 ShinyMetabase This is more a show case for the ShinyMetabase. My server is not powerful enough to handle large dataset. Install the package and run on your local machine is recommended for now. diet-tracker This app has two parts. A user's interface to record daily diet intake, and an admin's dashboard to manage all users and see all of their records. Mix Modeler An app allows you to copy paste your data from Excel and run linear model. Power Calculator An app to run power calculator with given means and SDs of two groups. About me \u00b6","title":"Home"},{"location":"#chenghaos-project-site","text":"","title":"Chenghao's Project Site"},{"location":"#research-studies","text":"Fast Food Study Egg Study Ghana Study Alzheimer Study","title":" Research Studies"},{"location":"#github-projects","text":"Metabase R package for storing, handling, anlyzing, and visualizing high though-put experiment data, such as metabolomics and proteomics. ShinyMetabase A shiny app wrapped in an R package for metabolomics data analysis, including data normalization, linear model, multivariable analysis and network analysis. phylox R package for storing, handling, analyzing and visualizing phylogenic sequencing data in different phylogenic levels. zheatmap R package for generating clustered and annotated heatmaps using ggplot2 package. ggmetaplots R package with encapsulated functions to generate different plots that is frequently used, such as boxplot and scatterplot.","title":"  Github Projects"},{"location":"#softwaresapps","text":"ShinyMetabase This is more a show case for the ShinyMetabase. My server is not powerful enough to handle large dataset. Install the package and run on your local machine is recommended for now. diet-tracker This app has two parts. A user's interface to record daily diet intake, and an admin's dashboard to manage all users and see all of their records. Mix Modeler An app allows you to copy paste your data from Excel and run linear model. Power Calculator An app to run power calculator with given means and SDs of two groups.","title":" Softwares/Apps"},{"location":"#about-me","text":"","title":" About me"},{"location":"docs/","text":"Vignettes Introduction to Metabase Metabase: importing data from wcmc report phylox: basic usage zheatmap: basic usage","title":"Documentations"},{"location":"moocs/","text":"Taking online courses is an extremely good way to learn coding, algorithm, or other computation skills for me. Here I listed some good courses that I took. Tip Coursera's courses aren't cheap. If you buy one course at a time, it's usually $79 per course. If you subscript a specialization (which is a series of courses) it's $49 per month. However, if you don't have any credit cards bonded to the website yet(or register a new account if you already did), you can audit without paying anything. You can't take quizzes, submit any projects, or get any certificate. But if you just want to learn the material, it might be a good choice. Data Science Specialization \u00b6 @coursera, by JHU This is a very thorough and well-structured series courses with 10 courses about statistics and R, hosted by the department od Biostatistics in John Hopkins University. It stats with the very basic R programming, then into statistics theoreis (distribution and linear model). It has a very inspiring course called \"reproducible research\" which I think is extremely necessary for us when handling with big datasets. Same as the one below, this specialization is free to audit, and $49 per month is you enroll it to get certificates. The first week is free, and I finished the 9/10 in only two months. Genomic Data Science \u00b6 @coursera, by JHU This is also a series course with 8 courses, also hosted by JHU. This course is extremely useful especially when you want to work with microbiome data, proteomic data, or any HTS(high through-put sequencing) data. It covers the NGS sequencing theory, and the genomic sequences alignment algorithm (with python), unix system operation (most genomic tools were developed in linux platform, such as the QIIME2), and then data analysis. Bioinformaitcs Specialization \u00b6 @coursera, by UCSD This is an replacement of the course above. It was recommended by many people but I didn't take it. Python for Everybody \u00b6 @coursera, by UMich A wonderful series of courses of python for absolute beginners. The professor is very funny and very easy to understand. It teaches the most fundamental data structure and programming skills of python.","title":"Online Courses"},{"location":"moocs/#data-science-specialization","text":"@coursera, by JHU This is a very thorough and well-structured series courses with 10 courses about statistics and R, hosted by the department od Biostatistics in John Hopkins University. It stats with the very basic R programming, then into statistics theoreis (distribution and linear model). It has a very inspiring course called \"reproducible research\" which I think is extremely necessary for us when handling with big datasets. Same as the one below, this specialization is free to audit, and $49 per month is you enroll it to get certificates. The first week is free, and I finished the 9/10 in only two months.","title":"Data Science Specialization"},{"location":"moocs/#genomic-data-science","text":"@coursera, by JHU This is also a series course with 8 courses, also hosted by JHU. This course is extremely useful especially when you want to work with microbiome data, proteomic data, or any HTS(high through-put sequencing) data. It covers the NGS sequencing theory, and the genomic sequences alignment algorithm (with python), unix system operation (most genomic tools were developed in linux platform, such as the QIIME2), and then data analysis.","title":"Genomic Data Science"},{"location":"moocs/#bioinformaitcs-specialization","text":"@coursera, by UCSD This is an replacement of the course above. It was recommended by many people but I didn't take it.","title":"Bioinformaitcs Specialization"},{"location":"moocs/#python-for-everybody","text":"@coursera, by UMich A wonderful series of courses of python for absolute beginners. The professor is very funny and very easy to understand. It teaches the most fundamental data structure and programming skills of python.","title":"Python for Everybody"},{"location":"presents/","text":"Introduction to High Throughput Experiment Data Analysis \u00b6 [ github repo ] [ view slides ] Presentated at the Zivkovic Lab meeting (07/25/2018) The Art of Data Analysis \u00b6 [ github repo ] [ view slides ] Presentated at the Zivkovic Lab meeting (09/25/2018)","title":"Presentations"},{"location":"presents/#introduction-to-high-throughput-experiment-data-analysis","text":"[ github repo ] [ view slides ] Presentated at the Zivkovic Lab meeting (07/25/2018)","title":" Introduction to High Throughput Experiment Data Analysis"},{"location":"presents/#the-art-of-data-analysis","text":"[ github repo ] [ view slides ] Presentated at the Zivkovic Lab meeting (09/25/2018)","title":" The Art of Data Analysis"},{"location":"tutorials/","text":"QIIME2 \u00b6 Qiime2 is actively under developing, with new version released every other month. By the time that I wrote this, qiime2's DADA2 function is much slower (plus there is some problem that we haven't solved of using qiime2's dada2). However, qiime2 is embedded with the fasttree tool. So if you want to use it to build a phylogenic tree, please read the tutorial in qiime2 website, and make sure to use the latest version. DADA2 Tutorial \u00b6 The original dada2 is a R package available on bioconductor. PICRUSt Tutorial with de novo Variants \u00b6 This tutorial allows you to use dada2 output to do function prediction with PICRUSt. Phyloseq \u00b6 Phyloseq is a package that dedicated for microbiome data analysis. It can calculate the alpha diversity, and beta diversity with different methods (unifrac, bray curtis, etc.). But it does not have a phylogenic tree building method which is required by the unifrac method. So you will need to use the qiime2 before phyloseq. The phyloseq's plotting functions are very capsulized, and not very flexible.","title":"Tutorials"},{"location":"tutorials/#qiime2","text":"Qiime2 is actively under developing, with new version released every other month. By the time that I wrote this, qiime2's DADA2 function is much slower (plus there is some problem that we haven't solved of using qiime2's dada2). However, qiime2 is embedded with the fasttree tool. So if you want to use it to build a phylogenic tree, please read the tutorial in qiime2 website, and make sure to use the latest version.","title":"QIIME2"},{"location":"tutorials/#dada2-tutorial","text":"The original dada2 is a R package available on bioconductor.","title":"DADA2 Tutorial"},{"location":"tutorials/#picrust-tutorial-with-de-novo-variants","text":"This tutorial allows you to use dada2 output to do function prediction with PICRUSt.","title":"PICRUSt Tutorial with de novo Variants"},{"location":"tutorials/#phyloseq","text":"Phyloseq is a package that dedicated for microbiome data analysis. It can calculate the alpha diversity, and beta diversity with different methods (unifrac, bray curtis, etc.). But it does not have a phylogenic tree building method which is required by the unifrac method. So you will need to use the qiime2 before phyloseq. The phyloseq's plotting functions are very capsulized, and not very flexible.","title":"Phyloseq"},{"location":"workflows/","text":"Workflows 16S Amplicon Sequence Data Demultiplex [ html workflow ] [ download .ipynb ] [ download additional tool ] DADA2 workflow [ html workflow ] [ download .Rmd ] [ download the data cleaning script ] PICRUSt [ html workflow ] [ download .ipynb ]","title":"Workflows"},{"location":"posts/chinese/","text":"match.call, R\u8bed\u8a00\u4e2d\u7684\u4e24\u4e2a\u5751 [2019-03-22]","title":"blogs"},{"location":"posts/english/","text":"match.call, a double pitfall in R [2019-03-22]","title":"blogs"},{"location":"posts/chinese/2019-03-22/","text":"match.call, R\u8bed\u8a00\u7684\u4e00\u4e2a\u8fde\u73af\u5751 \u00b6 \u6709\u65f6\u5019\u4f1a\u9700\u8981\u5199\u4e00\u4e9b\u76f8\u4e92\u4f9d\u8d56\u7684\u51fd\u6570\u4ee5\u907f\u514d\u4ee3\u7801\u7684\u91cd\u590d\u3002\u6bd4\u5982\u8bf4\u51fd\u6570A\u8c03\u7528\u51fd\u6570B\uff0c\u51fd\u6570B\u8c03\u7528\u51fd\u6570C\u3002\u4f46\u4e0d\u540c\u51fd\u6570\u7684arguments \u4f1a\u4e0d\u4e00\u6837\u3002\u5728\u51fd\u6570A\u4e2d\u6307\u5b9a\u6bcf\u4e00\u4e2a\u51fd\u6570B\u4e2d\u6240\u7528\u5230\u7684\u53c2\u6570\u4f1a\u4e0d\u591f\u7075\u6d3b\u3002\u90a3\u66f4\u52a0\u7075\u6d3b\u7684\u65b9\u5f0f\u662f\u7528 ... \u3002 \u5f53\u51fd\u6570\u7684\u53c2\u6570\u5217\u8868\u7684\u6700\u540e\u6709 ... \u65f6R \u4f1a\u81ea\u52a8\u628a\u4efb\u4f55\u6ca1\u6709\u5339\u914d\u7684\u51fd\u6570\u653e\u8fdb\u53bb\u3002\u90a3\u83b7\u53d6\u8fd9\u4e9b\u53c2\u6570\u7684\u65b9\u5f0f\uff0c\u53ef\u4ee5\u7528 match.call() \u6216\u8005 sys.call() \u3002\u8fd9\u4e24\u8005\u7684\u533a\u522b\u662f\uff0c\u524d\u8005\u8fd4\u56de\u4e00\u4e2anamed list\uff0c\u800c\u540e\u8005\u662f unnamed list\u3002 \u4f46\u548cpython \u91cc\u7684 *args \u548c **kwargs \u7684\u533a\u522b\u5728\u4e8e match.call() \u548c sys.call() \u4f1a\u5339\u914d\u6240\u6709\u7684\u53c2\u6570\u800c\u4e0d\u4ec5\u4ec5\u662f ... \uff08which is not a problem\uff09\u3002\u90a3\u83b7\u53d6\u4e86\u7684\u53c2\u6570\u5c31\u53ef\u4ee5\u4efb\u610f\u5904\u7406\uff0c\u8f6c\u6362\uff0c\u6700\u540e\u7528 do.call() \u4f20\u9012\u5230\u8c03\u7528\u7684\u51fd\u6570\u4e2d\u3002 \u4e3e\u4e2a\u4f8b\u5b50\uff0c\u4e0b\u9762\u5b9a\u4e49\u4e86\u4e24\u4e2a\u51fd\u6570\u3002 my_sum \u628a3\u4e2a\u6570\u5b57\u76f8\u52a0, \u800c sqr_sum \u5219\u4f1a\u5148\u628a\u6ca1\u4e00\u4e2a\u6570\u503c\u4e58\u65b9\u518d\u8c03\u7528 my_sum \u76f8\u52a0\u3002 my_sum = function(x, y, z){ return(x + y + z) } sqr_sum = function(...){ args = as.list(match.call())[-1] args = lapply(args, function(x) x^2) do.call(my_sum, args) } sqr_sum(x = 2, y = 3, z = 4) # [1] 29 \u5b8c\u7f8e\u3002\u4f46\u662f\uff0c\u5982\u679c\u5982\u679c sqr_sum \u88ab\u53e6\u4e00\u4e2a\u51fd\u6570\u8c03\u7528\u7684\u65f6\u5019\uff0c\u5751\u5c31\u51fa\u73b0\u4e86\u3002 add_sqr_sum \u51fd\u6570\u5148\u7ed9\u6bcf\u4e00\u4e2a\u6570\u52a0\u4e0a\u4e00\u4e2a\u503c\uff0c\u518d\u8c03\u7528 sqr_sum add_sqr_sum = function(x, y, z){ x = x + 5 y = y + 6 z = z + 7 sqr_sum(x = x, y = y, z = z) } add_sqr_sum(2,3,4) # Error in x^2 : non-numeric argument to binary operator \u7528 traceback \u4f1a\u53d1\u73b0\uff0c\u9519\u8bef\u53d1\u751f\u5728 sqr_sum \u91cc\u9762\u3002 sqr_sum \u4f3c\u4e4e\u662f\u63a5\u6536\u5230\u4e86 x \uff0c\u4f46 x \u5e76\u4e0d\u662fnumeric\u3002\u6539\u5199\u4e00\u4e0b sqr_sum \uff0c\u628a\u6211\u4eec\u7528 match.call() \u5339\u914d\u5230\u7684 args \u90fd\u6253\u51fa\u6765\u77a7\u77a7\u3002 sqr_sum = function(...){ args = as.list(match.call())[-1] print(args) # args = lapply(args, function(x) x^2) # do.call(my_sum, args) } add_sqr_sum(2,3,4) # $x # x # # $y # y # # $z # z \u8c8c\u4f3c args \u91cc\u7684\u503c\uff0c\u90fd\u662f\u672a\u88ab eval \u8fc7\u7684 symbol \u800c\u975e numeric \u3002\u90a3\u54b1\u8bd5\u8bd5\u76f4\u63a5\u5728global environment \u91cc\u662f\u7528 sqr_sum \u3002 sqr_sum(2,3,4) # $x # [1] 2 # # $y # [1] 3 # # $z # [1] 4 \u90a3\u5f88\u663e\u7136\u8fd9\u4e00\u6b21 args \u91cc\u7684 element \u90fd\u662f\u6570\u503c\u4e86\u3002\u4f46\u662f\u5982\u679c\u5728global environment \u91cc\uff0c\u5f53\u4f60\u628a\u4e00\u4e2a\u53d8\u91cf\u4f20\u5165\u65f6\uff0c\u540c\u6837\u7684\u95ee\u9898\u4e5f\u4f1a\u53d1\u751f x = 2 sqr_sum(x = x, y = 3, z = 4) # $x # x # # $y # [1] 3 # # $z # [1] 4 \u6240\u4ee5\u95ee\u9898\u5c31\u5728\u4e8e\uff0c match.call() \u8fd9\u4e2a\u51fd\u6570\uff0c\u53ea\u4f1a\u611a\u8822\u5730\u628a\u4f20\u5165\u7684\u53c2\u6570\u7ed9match \u4e0b\u6765\u3002\u8fd9\u610f\u5473\u7740\uff0c\u5982\u679c\u4f20\u5165\u7684\u662f numeric \uff0c\u90a3\u5c31\u662f numeric \uff0c\u4f20\u5165\u7684\u662f character \u5c31\u662f character \uff0c\u800c\u5982\u679c\u4f20\u5165\u7684\u662f\u4e00\u4e2a\u53d8\u91cf\u7684\u8bdd\uff0c\u5b83\u53ea\u4f1a\u628a symbol \u4fdd\u7559\uff0c\u800c\u4e0d\u4f1a\u5728**calling environment**\u4e2d\u53bb eval \u3002\u56e0\u6b64\u89e3\u51b3\u65b9\u6848\u5176\u5b9e\u5f88\u7b80\u5355\uff0c\u628a\u4efb\u4f55\u7684 symbol \u4eba\u4e3a\u5730 eval \u3002 sqr_sum = function(...){ args = as.list(match.call())[-1] call.envir = parent.frame(1) args = lapply(args, function(arg){ if(is.symbol(arg)){ eval(arg, envir = call.envir) } else { arg } }) args = lapply(args, function(x) x^2) do.call(my_sum, args) } sqr_sum(x = x, y = 3, z = 4) # 29 add_sqr_sum(2,3,4) # 251 \u4e16\u754c\u53c8\u53d8\u5f97\u7f8e\u597d\u4e86\u3002 \u5728\u8fd9\u8fc7\u7a0b\u5f53\u4e2d\u8fd8\u53d1\u73b0 match.call \u53e6\u5916\u7684\u4e00\u4e2a\u5751\u3002\u4ee5\u4e0b\u662f\u6587\u6863\u4e2d\u7684 usage \u3002 # Usage match.call(definition = sys.function(sys.parent()), call = sys.call(sys.parent()), expand.dots = TRUE, envir = parent.frame(2L)) \u6587\u6863\u58f0\u79f0\uff0c definition \u548c call \u90fd\u662f\u4f7f\u7528\u7684\u662f\u4f7f\u7528\u4e86 match.call \u7684\u8fd9\u4e2a\u51fd\u6570\u7684 parent enviroment\u3002 match.call \u6ca1\u6cd5\u76f4\u63a5\u67e5\u770b\u6e90\u4ee3\u7801\uff08\u8c8c\u4f3c\u662f\u4e00\u4e2ainternal function\uff09\u4f46\u662f\u5c1d\u8bd5\u4e00\u756a\u4e4b\u540e\u5c31\u4f1a\u53d1\u73b0\uff0c\u5b9e\u9645\u4e0a definition \u548c call \u90fd\u662f\u4f7f\u7528\u7684\u662f\u8be5\u51fd\u6570\u6240\u5728\u7684 environment \u800c\u975e parent environment\u3002\u56e0\u6b64\u6b63\u786e\u7684default parameter \u5176\u5b9e\u5982\u4e0b\uff1a match.call(definition = sys.function(0), call = sys.call(0), expand.dots = TRUE, envir = parent.frame(2L)) \u4ee5\u4e0a\u4fbf\u662f match.call \u7684\u4e24\u4e2a\u5751\u3002","title":"match.call"},{"location":"posts/chinese/2019-03-22/#matchcall-r","text":"\u6709\u65f6\u5019\u4f1a\u9700\u8981\u5199\u4e00\u4e9b\u76f8\u4e92\u4f9d\u8d56\u7684\u51fd\u6570\u4ee5\u907f\u514d\u4ee3\u7801\u7684\u91cd\u590d\u3002\u6bd4\u5982\u8bf4\u51fd\u6570A\u8c03\u7528\u51fd\u6570B\uff0c\u51fd\u6570B\u8c03\u7528\u51fd\u6570C\u3002\u4f46\u4e0d\u540c\u51fd\u6570\u7684arguments \u4f1a\u4e0d\u4e00\u6837\u3002\u5728\u51fd\u6570A\u4e2d\u6307\u5b9a\u6bcf\u4e00\u4e2a\u51fd\u6570B\u4e2d\u6240\u7528\u5230\u7684\u53c2\u6570\u4f1a\u4e0d\u591f\u7075\u6d3b\u3002\u90a3\u66f4\u52a0\u7075\u6d3b\u7684\u65b9\u5f0f\u662f\u7528 ... \u3002 \u5f53\u51fd\u6570\u7684\u53c2\u6570\u5217\u8868\u7684\u6700\u540e\u6709 ... \u65f6R \u4f1a\u81ea\u52a8\u628a\u4efb\u4f55\u6ca1\u6709\u5339\u914d\u7684\u51fd\u6570\u653e\u8fdb\u53bb\u3002\u90a3\u83b7\u53d6\u8fd9\u4e9b\u53c2\u6570\u7684\u65b9\u5f0f\uff0c\u53ef\u4ee5\u7528 match.call() \u6216\u8005 sys.call() \u3002\u8fd9\u4e24\u8005\u7684\u533a\u522b\u662f\uff0c\u524d\u8005\u8fd4\u56de\u4e00\u4e2anamed list\uff0c\u800c\u540e\u8005\u662f unnamed list\u3002 \u4f46\u548cpython \u91cc\u7684 *args \u548c **kwargs \u7684\u533a\u522b\u5728\u4e8e match.call() \u548c sys.call() \u4f1a\u5339\u914d\u6240\u6709\u7684\u53c2\u6570\u800c\u4e0d\u4ec5\u4ec5\u662f ... \uff08which is not a problem\uff09\u3002\u90a3\u83b7\u53d6\u4e86\u7684\u53c2\u6570\u5c31\u53ef\u4ee5\u4efb\u610f\u5904\u7406\uff0c\u8f6c\u6362\uff0c\u6700\u540e\u7528 do.call() \u4f20\u9012\u5230\u8c03\u7528\u7684\u51fd\u6570\u4e2d\u3002 \u4e3e\u4e2a\u4f8b\u5b50\uff0c\u4e0b\u9762\u5b9a\u4e49\u4e86\u4e24\u4e2a\u51fd\u6570\u3002 my_sum \u628a3\u4e2a\u6570\u5b57\u76f8\u52a0, \u800c sqr_sum \u5219\u4f1a\u5148\u628a\u6ca1\u4e00\u4e2a\u6570\u503c\u4e58\u65b9\u518d\u8c03\u7528 my_sum \u76f8\u52a0\u3002 my_sum = function(x, y, z){ return(x + y + z) } sqr_sum = function(...){ args = as.list(match.call())[-1] args = lapply(args, function(x) x^2) do.call(my_sum, args) } sqr_sum(x = 2, y = 3, z = 4) # [1] 29 \u5b8c\u7f8e\u3002\u4f46\u662f\uff0c\u5982\u679c\u5982\u679c sqr_sum \u88ab\u53e6\u4e00\u4e2a\u51fd\u6570\u8c03\u7528\u7684\u65f6\u5019\uff0c\u5751\u5c31\u51fa\u73b0\u4e86\u3002 add_sqr_sum \u51fd\u6570\u5148\u7ed9\u6bcf\u4e00\u4e2a\u6570\u52a0\u4e0a\u4e00\u4e2a\u503c\uff0c\u518d\u8c03\u7528 sqr_sum add_sqr_sum = function(x, y, z){ x = x + 5 y = y + 6 z = z + 7 sqr_sum(x = x, y = y, z = z) } add_sqr_sum(2,3,4) # Error in x^2 : non-numeric argument to binary operator \u7528 traceback \u4f1a\u53d1\u73b0\uff0c\u9519\u8bef\u53d1\u751f\u5728 sqr_sum \u91cc\u9762\u3002 sqr_sum \u4f3c\u4e4e\u662f\u63a5\u6536\u5230\u4e86 x \uff0c\u4f46 x \u5e76\u4e0d\u662fnumeric\u3002\u6539\u5199\u4e00\u4e0b sqr_sum \uff0c\u628a\u6211\u4eec\u7528 match.call() \u5339\u914d\u5230\u7684 args \u90fd\u6253\u51fa\u6765\u77a7\u77a7\u3002 sqr_sum = function(...){ args = as.list(match.call())[-1] print(args) # args = lapply(args, function(x) x^2) # do.call(my_sum, args) } add_sqr_sum(2,3,4) # $x # x # # $y # y # # $z # z \u8c8c\u4f3c args \u91cc\u7684\u503c\uff0c\u90fd\u662f\u672a\u88ab eval \u8fc7\u7684 symbol \u800c\u975e numeric \u3002\u90a3\u54b1\u8bd5\u8bd5\u76f4\u63a5\u5728global environment \u91cc\u662f\u7528 sqr_sum \u3002 sqr_sum(2,3,4) # $x # [1] 2 # # $y # [1] 3 # # $z # [1] 4 \u90a3\u5f88\u663e\u7136\u8fd9\u4e00\u6b21 args \u91cc\u7684 element \u90fd\u662f\u6570\u503c\u4e86\u3002\u4f46\u662f\u5982\u679c\u5728global environment \u91cc\uff0c\u5f53\u4f60\u628a\u4e00\u4e2a\u53d8\u91cf\u4f20\u5165\u65f6\uff0c\u540c\u6837\u7684\u95ee\u9898\u4e5f\u4f1a\u53d1\u751f x = 2 sqr_sum(x = x, y = 3, z = 4) # $x # x # # $y # [1] 3 # # $z # [1] 4 \u6240\u4ee5\u95ee\u9898\u5c31\u5728\u4e8e\uff0c match.call() \u8fd9\u4e2a\u51fd\u6570\uff0c\u53ea\u4f1a\u611a\u8822\u5730\u628a\u4f20\u5165\u7684\u53c2\u6570\u7ed9match \u4e0b\u6765\u3002\u8fd9\u610f\u5473\u7740\uff0c\u5982\u679c\u4f20\u5165\u7684\u662f numeric \uff0c\u90a3\u5c31\u662f numeric \uff0c\u4f20\u5165\u7684\u662f character \u5c31\u662f character \uff0c\u800c\u5982\u679c\u4f20\u5165\u7684\u662f\u4e00\u4e2a\u53d8\u91cf\u7684\u8bdd\uff0c\u5b83\u53ea\u4f1a\u628a symbol \u4fdd\u7559\uff0c\u800c\u4e0d\u4f1a\u5728**calling environment**\u4e2d\u53bb eval \u3002\u56e0\u6b64\u89e3\u51b3\u65b9\u6848\u5176\u5b9e\u5f88\u7b80\u5355\uff0c\u628a\u4efb\u4f55\u7684 symbol \u4eba\u4e3a\u5730 eval \u3002 sqr_sum = function(...){ args = as.list(match.call())[-1] call.envir = parent.frame(1) args = lapply(args, function(arg){ if(is.symbol(arg)){ eval(arg, envir = call.envir) } else { arg } }) args = lapply(args, function(x) x^2) do.call(my_sum, args) } sqr_sum(x = x, y = 3, z = 4) # 29 add_sqr_sum(2,3,4) # 251 \u4e16\u754c\u53c8\u53d8\u5f97\u7f8e\u597d\u4e86\u3002 \u5728\u8fd9\u8fc7\u7a0b\u5f53\u4e2d\u8fd8\u53d1\u73b0 match.call \u53e6\u5916\u7684\u4e00\u4e2a\u5751\u3002\u4ee5\u4e0b\u662f\u6587\u6863\u4e2d\u7684 usage \u3002 # Usage match.call(definition = sys.function(sys.parent()), call = sys.call(sys.parent()), expand.dots = TRUE, envir = parent.frame(2L)) \u6587\u6863\u58f0\u79f0\uff0c definition \u548c call \u90fd\u662f\u4f7f\u7528\u7684\u662f\u4f7f\u7528\u4e86 match.call \u7684\u8fd9\u4e2a\u51fd\u6570\u7684 parent enviroment\u3002 match.call \u6ca1\u6cd5\u76f4\u63a5\u67e5\u770b\u6e90\u4ee3\u7801\uff08\u8c8c\u4f3c\u662f\u4e00\u4e2ainternal function\uff09\u4f46\u662f\u5c1d\u8bd5\u4e00\u756a\u4e4b\u540e\u5c31\u4f1a\u53d1\u73b0\uff0c\u5b9e\u9645\u4e0a definition \u548c call \u90fd\u662f\u4f7f\u7528\u7684\u662f\u8be5\u51fd\u6570\u6240\u5728\u7684 environment \u800c\u975e parent environment\u3002\u56e0\u6b64\u6b63\u786e\u7684default parameter \u5176\u5b9e\u5982\u4e0b\uff1a match.call(definition = sys.function(0), call = sys.call(0), expand.dots = TRUE, envir = parent.frame(2L)) \u4ee5\u4e0a\u4fbf\u662f match.call \u7684\u4e24\u4e2a\u5751\u3002","title":"match.call, R\u8bed\u8a00\u7684\u4e00\u4e2a\u8fde\u73af\u5751"},{"location":"posts/english/2019-03-22/","text":"match.call, a pitall in R \u00b6 Sometimes you write a function A in which you call another function B, but you don't want to specify each single arguments defined by function B. So a solution is use ... after the last argument in A, using match.call() or sys.call to get all arguments, process all the arguments, and finally pass all arguments to function B using do.call . Here is a example. We define function my_sum which sum up three numbers together, and a function sqr_sum that square each number then sum them up. my_sum = function(x, y, z){ return(x + y + z) } sqr_sum = function(...){ args = as.list(match.call())[-1] args = lapply(args, function(x) x^2) do.call(my_sum, args) } sqr_sum(x = 2, y = 3, z = 4) # [1] 29 This is perfect, except if we are trying to call the sqr_sum inaother function. The add_sqr_sum function now add a value to each function, and then call the sqr_sum add_sqr_sum = function(x, y, z){ x = x + 5 y = y + 6 z = z + 7 sqr_sum(x = x, y = y, z = z) } add_sqr_sum(2,3,4) # Error in x^2 : non-numeric argument to binary operator If we use the traceback function we'll see the error occurs inside the sqr_sum function. So apparently we have the x , but it's not a numeric. Let's modify the sqr_sum function to print out thr args to see what really is going on. sqr_sum = function(...){ args = as.list(match.call())[-1] print(args) # args = lapply(args, function(x) x^2) # do.call(my_sum, args) } add_sqr_sum(2,3,4) # $x # x # # $y # y # # $z # z So each element of the args list is no longer a numeric value, but a unevaluated symbol . And if we call sqr_sum directly it is fine. sqr_sum(2,3,4) # $x # [1] 2 # # $y # [1] 3 # # $z # [1] 4 But the same problem happens if call sqr_sum directly using a global variable. x = 2 sqr_sum(x = x, y = 3, z = 4) # $x # x # # $y # [1] 3 # # $z # [1] 4 After working on this for hours, I finally found my solution. The solution is actually pretty easy. We just need to eval it if we got a symbol . After I add the new line in the sqr_sum function, it works fine. sqr_sum = function(...){ args = as.list(match.call())[-1] call.envir = parent.frame(1) args = lapply(args, function(arg){ if(is.symbol(arg)){ eval(arg, envir = call.envir) } else { arg } }) args = lapply(args, function(x) x^2) do.call(my_sum, args) } sqr_sum(x = x, y = 3, z = 4) # 29 add_sqr_sum(2,3,4) # 251 While trying to figure this out, I also found another pitfall in the match.call function. # Usage match.call(definition = sys.function(sys.parent()), call = sys.call(sys.parent()), expand.dots = TRUE, envir = parent.frame(2L)) The documentation of match.call says that the definition and call are using the parent environment which is the environment where the function with match.call inside is called. And the envir uses the grand-parent environment. But this is not true. Although this function is a internal function that we can not see the source code, but after I tried some combinations, the default parameter is actually below. match.call(definition = sys.function(0), call = sys.call(0), expand.dots = TRUE, envir = parent.frame(2L))","title":"match.call"},{"location":"posts/english/2019-03-22/#matchcall-a-pitall-in-r","text":"Sometimes you write a function A in which you call another function B, but you don't want to specify each single arguments defined by function B. So a solution is use ... after the last argument in A, using match.call() or sys.call to get all arguments, process all the arguments, and finally pass all arguments to function B using do.call . Here is a example. We define function my_sum which sum up three numbers together, and a function sqr_sum that square each number then sum them up. my_sum = function(x, y, z){ return(x + y + z) } sqr_sum = function(...){ args = as.list(match.call())[-1] args = lapply(args, function(x) x^2) do.call(my_sum, args) } sqr_sum(x = 2, y = 3, z = 4) # [1] 29 This is perfect, except if we are trying to call the sqr_sum inaother function. The add_sqr_sum function now add a value to each function, and then call the sqr_sum add_sqr_sum = function(x, y, z){ x = x + 5 y = y + 6 z = z + 7 sqr_sum(x = x, y = y, z = z) } add_sqr_sum(2,3,4) # Error in x^2 : non-numeric argument to binary operator If we use the traceback function we'll see the error occurs inside the sqr_sum function. So apparently we have the x , but it's not a numeric. Let's modify the sqr_sum function to print out thr args to see what really is going on. sqr_sum = function(...){ args = as.list(match.call())[-1] print(args) # args = lapply(args, function(x) x^2) # do.call(my_sum, args) } add_sqr_sum(2,3,4) # $x # x # # $y # y # # $z # z So each element of the args list is no longer a numeric value, but a unevaluated symbol . And if we call sqr_sum directly it is fine. sqr_sum(2,3,4) # $x # [1] 2 # # $y # [1] 3 # # $z # [1] 4 But the same problem happens if call sqr_sum directly using a global variable. x = 2 sqr_sum(x = x, y = 3, z = 4) # $x # x # # $y # [1] 3 # # $z # [1] 4 After working on this for hours, I finally found my solution. The solution is actually pretty easy. We just need to eval it if we got a symbol . After I add the new line in the sqr_sum function, it works fine. sqr_sum = function(...){ args = as.list(match.call())[-1] call.envir = parent.frame(1) args = lapply(args, function(arg){ if(is.symbol(arg)){ eval(arg, envir = call.envir) } else { arg } }) args = lapply(args, function(x) x^2) do.call(my_sum, args) } sqr_sum(x = x, y = 3, z = 4) # 29 add_sqr_sum(2,3,4) # 251 While trying to figure this out, I also found another pitfall in the match.call function. # Usage match.call(definition = sys.function(sys.parent()), call = sys.call(sys.parent()), expand.dots = TRUE, envir = parent.frame(2L)) The documentation of match.call says that the definition and call are using the parent environment which is the environment where the function with match.call inside is called. And the envir uses the grand-parent environment. But this is not true. Although this function is a internal function that we can not see the source code, but after I tried some combinations, the default parameter is actually below. match.call(definition = sys.function(0), call = sys.call(0), expand.dots = TRUE, envir = parent.frame(2L))","title":"match.call, a pitall in R"}]}